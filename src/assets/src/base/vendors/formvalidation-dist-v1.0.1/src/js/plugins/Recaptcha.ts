/**
 * FormValidation (https://formvalidation.io)
 * The best validation library for JavaScript
 * (c) 2013 - 2018 Nguyen Huu Phuoc <me@phuoc.ng>
 */

import { FieldResetEvent, Localization, ValidateInput } from '../core/Core';
import Plugin from '../core/Plugin';
import Status from '../core/Status';
import { CallbackOptions } from '../validators/callback';

export interface RecaptchaOptions {
    // The ID of element showing the captcha
    element: string;
    // The language code defined by reCAPTCHA
    // See https://developers.google.com/recaptcha/docs/language
    language?: string;
    // The invalid message that will be shown in case the captcha is not valid
    // You don't need to define it if the back-end URL above returns the message
    message: string;
    // The secure token
    secureToken?: string;
    // The site key provided by Google
    siteKey: string;
    // The theme name provided by Google. It can be light (default), dark
    theme?: string;
    // The number of seconds that session will expire
    timeout?: number;
}

/**
 * This plugin shows and validates a Google reCAPTCHA v2
 * Usage:
 * - Register a ReCaptcha API key
 * - Prepare a container to show the captcha
 *  ```
 *  <form id="testForm">
 *      <div id="captchaContainer"></div>
 *  </form>
 *  ```
 * - Use the plugin
 *  ```
 *  formValidation(document.getElementById('testForm'), {
 *      plugins: {
 *          recaptcha: new Recaptcha({
 *              element: 'captchaContainer',
 *              theme: 'light',
 *              siteKey: '...', // The key provided by Google
 *              language: 'en',
 *              message: 'The captcha is not valid'
 *          })
 *      }
 *  })
 *  ```
 */
export default class Recaptcha extends Plugin<RecaptchaOptions> {
    public static DEFAULT_ID = 'Recaptcha';

    // The captcha field name, generated by Google reCAPTCHA
    public static CAPTCHA_FIELD = 'g-recaptcha-response';

    public static DEFAULT_OPTIONS = {
        theme: 'light',
        // The default session timeout (in seconds)
        timeout: 2 * 60,
    };

    // The name of callback that will be executed after reCaptcha script is loaded
    public static LOADED_CALLBACK = '___reCaptchaLoaded___';

    private widgetIds: Map<string, string>;
    private fieldResetHandler: (e: FieldResetEvent) => void;

    constructor(opts?: RecaptchaOptions) {
        super(opts);
        this.widgetIds = new Map();
        this.opts = Object.assign({}, Recaptcha.DEFAULT_OPTIONS, opts);
        this.fieldResetHandler = this.onResetField.bind(this);
    }

    public install(): void {
        this.core.on('core.field.reset', this.fieldResetHandler);

        const loadPrevCaptcha = (typeof window[Recaptcha.LOADED_CALLBACK] === 'undefined')
            ? () => {} // tslint:disable-line:no-empty
            : window[Recaptcha.LOADED_CALLBACK];
        window[Recaptcha.LOADED_CALLBACK] = () => {
            // Call the previous loaded function
            // to support multiple recaptchas on the same page
            loadPrevCaptcha();

            const captchaOptions = {
                callback: (response) => {
                    // Get verified
                    this.core.updateFieldStatus(Recaptcha.CAPTCHA_FIELD, Status.Valid);

                    setTimeout(() => {
                        // Update the captcha status when session expires
                        this.core.updateFieldStatus(Recaptcha.CAPTCHA_FIELD, Status.Invalid);
                    }, this.opts.timeout * 1000);
                },
                sitekey: this.opts.siteKey,
                stoken: this.opts.secureToken || null,
                theme: this.opts.theme,
            };

            // tslint:disable-next-line:no-string-literal
            const widgetId = window['grecaptcha'].render(this.opts.element, captchaOptions);
            this.widgetIds.set(this.opts.element, widgetId);

            setTimeout(() => {
                this.core.addField(Recaptcha.CAPTCHA_FIELD, {
                    validators: {
                        callback: {
                            callback: (input: ValidateInput<CallbackOptions, Localization>) => {
                                return input.value !== '';
                            },
                            message: this.opts.message,
                        },
                    },
                });
            }, 3000);
        };

        const src = this.getScript();
        if (!document.body.querySelector(`script[src="${src}"]`)) {
            const script = document.createElement('script');
            script.type = 'text/javascript';
            script.async = true;
            script.defer = true;
            script.src = src;
            document.body.appendChild(script);
        }
    }

    public uninstall(): void {
        this.core.off('core.field.reset', this.fieldResetHandler);
        this.widgetIds.clear();

        // Remove script
        const src = this.getScript();
        const scripts = [].slice.call(document.body.querySelectorAll(`script[src="${src}"]`)) as HTMLScriptElement[];
        scripts.forEach((s) => s.parentNode.removeChild(s));

        this.core.removeField(Recaptcha.CAPTCHA_FIELD);
    }

    private getScript(): string {
        const lang = this.opts.language ? `&hl=${this.opts.language}` : '';
        return `https://www.google.com/recaptcha/api.js?onload=${Recaptcha.LOADED_CALLBACK}&render=explicit${lang}`;
    }

    private onResetField(e: FieldResetEvent): void {
        if (e.field === Recaptcha.CAPTCHA_FIELD && this.widgetIds.has(this.opts.element)) {
            const widgetId = this.widgetIds.get(this.opts.element);
            window['grecaptcha'].reset(widgetId); // tslint:disable-line:no-string-literal
        }
    }
}
